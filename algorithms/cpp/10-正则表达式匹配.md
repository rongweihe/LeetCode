### 题目：

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。


示例 1：

输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/regular-expression-matching
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

本题有点难度，需要考虑各种情况，可以用递归来做，为什么可以用递归呢？因为从前往后每一个字符是否可以进行匹配的判断来源于前一个字符是否匹配OK。

### 大概思路如下：

- 若 p 为空，若 s 也为空，返回 true，反之返回 false。

- 若 p 的长度为 1，若 s 长度也为 1，且相同或是 p 为 '.' 则返回 true，反之返回 false。

- 若 p 的第二个字符不为 *，若此时 s 为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。

- 若 p 的第二个字符为 *，进行下列循环，条件是若 s 不为空且首字符匹配（包括 p[0] 为点），调用递归函数匹配 s 和去掉前两个字符的 p（这样做的原因是假设此时的星号的作用是让前面的字符出现 0 次，验证是否匹配），若匹配返回 true，否则 s 去掉首字母（因为此时首字母匹配了，我们可以去掉 s 的首字母，而 p 由于星号的作用，可以有任意个首字母，所以不需要去掉），继续进行循环。

- 返回调用递归函数匹配 s 和去掉前两个字符的 p 的结果（这么做的原因是处理星号无法匹配的内容，比如 s="ab", p="a*b"，直接进入 while 循环后，我们发现 "ab" 和 "b" 不匹配，所以s变成 "b"，那么此时跳出循环后，就到最后的 return 来比较 "b" 和 "b" 了，返回 true。再举个例子，比如 s="", p="a*"，由于s为空，不会进入任何的 if 和 while，只能到最后的 return 来比较了，返回 true，正确）。

### 参考代码

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        if (p.empty()) return s.empty();//都为空
        if (p.size() == 1) {
            return (s.size() == 1 && (s[0] == p[0] || p[0] == '.')); //单个字符的判断：字符相等或匹配.号
        }
        if (p[1] != '*') {
            if (s.empty()) return false;
            return (p[0] == s[0] || p[0] == '.') && isMatch(s.substr(1), p.substr(1));
            //若p的第二个字符不为*，若此时s为空返回 false，否则判断首字符是否匹配，且从各自的第二个字符开始调用递归函数匹配。(为什么从第二个字符递归判断 因为第一个字符已经做了判断)
        }
        while(!s.empty() && (s[0] == p[0] || p[0] == '.')) {
            if (isMatch(s, p.substr(2))) return true;
            s = s.substr(1);
        }
        return isMatch(s, p.substr(2));
        //这么做的原因是处理星号无法匹配的内容
    }
};
```

