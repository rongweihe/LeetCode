## 思路一：双指针法

时间O(N^2) 空间O(N)

道理想明白就简单了

很明显每个柱子顶部可以储水的高度为：该柱子的左右两侧最大高度的较小者减去此柱子的高度。

因此我们只需要遍历每个柱子，累加每个柱子可以储水的高度即可。

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0, sz = height.size();
        std::stack<int>st;
        for (int i=0; i< sz; ++i) {
            if (i == 0 || i == sz - 1) continue; //第一个柱子和最后柱子不接水
            
            int lH = height[i];// 记录左边柱子的最高高度
            int rH = height[i];// 记录右边柱子的最高高度
            for (int l = i-1; l >= 0; --l) {
                if (height[l] > lH) lH = height[l];
            }
            for (int r = i+1; r < sz; ++r) {
                if (height[r] > rH) rH = height[r];
            }
            int h = min(lH, rH) - height[i];
            if (h) sum += h;
        }
        return sum;
    }
};
```

### 思路二：双指针优化

上面这个思路还可以在优化

res += Math.min(leftMax, rightMax) - height[i];

注意这里的 leftMax 是从左端开始递推得到的，而 rightMax 是从右端开始递推得到的。

因此遍历每个柱子，累加每个柱子的储水高度时，也需要用 left 和 right 两个指针从两端开始遍历。

**时间O(N) 空间O(1)（目前最优）**

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0, sz = height.size();
        int left = 0, right = sz - 1;
        int lM = 0, rM = 0;
        while (left <= right) {
             if (lM <= rM) {
                 lM = max(lM, height[left]);
                 sum += lM - height[left++];
             } else {
                 rM = max(rM, height[right]);
                 sum += rM - height[right--];
             }
        }
        return sum;
    }
};
```



## 思路三：单调栈

时间O(N) 空间O(N)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0, sz = height.size();
        std::stack<int>st;
        for (int i=0; i< sz; ++i) {
             while(!st.empty() && height[i] > height[st.top()]) {
                 int bottom = st.top();
                 while(!st.empty() && height[bottom] == height[st.top()]) {
                     st.pop();
                 }
                if (!st.empty()) {
                    sum += (min(height[st.top()], height[i]) - height[bottom]) * (i - st.top() - 1);
                }
             }
            st.push(i);
        }
        return sum;
    }
};
```

