746. 使用最小花费爬楼梯 https://leetcode-cn.com/problems/min-cost-climbing-stairs/


数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

 

示例 1：

输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

【思路】

动规五部曲

- 【1】确定dp数组（dp table）以及下标的含义
- 【2】确定递推公式
- 【3】dp数组如何初始化
- 【4】确定遍历顺序
- 【5】举例推导dp数组

确定dp数组以及下标的含义
使用动态规划，就要有一个数组来记录状态，本题只需要一个一维数组dp[i]就可以了。

dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]。（注意这里认为是第一步一定是要花费）

对于dp数组的定义，大家一定要清晰！

确定递推公式
可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。

那么究竟是选dp[i-1]还是dp[i-2]呢？

一定是选最小的，所以dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];

注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值

dp数组如何初始化
根据dp数组的定义，dp数组初始化其实是比较难的，因为不可能初始化为第i台阶所花费的最少体力。

那么看一下递归公式，dp[i]由dp[i-1]，dp[i-2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。



【参考代码】

```c++
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int len = cost.length;
        int dp[] = new int[len];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i < len; ++i) {
            dp[i] = Math.min(dp[i-1], dp[i-2]) + cost[i];
        }
        return Math.min(dp[len - 1], dp[len - 2]);
    }
}//dp[i] 表示从楼梯的第i级往上爬需要的最小成本

```
